
1. Why is the sorted ArrayList slower to add to than the Linked List?
The items in an ArraysList are ordered in memory. For a sorted ArrayList, everytime an object is added, the memory addresses of the objects following the location of the added item, must be moved forward in memory. This is memory intensive. A Linked List creates a new memory address for the added object, which then points to the next object in the list, and the previous object is pointed at the new object.
ArrayLists are efficient in accessing objects because if you know an index, you can access that space in memory. However they are inefficient in adding data because they are 1. fixed in size and 2. adding new indices requires the copying of all the data to a new array with the new object inserted.

2. I thought we said that arrays are slow. Why is add so quick for the unsorted array? What kind of search is the sorted array using? Is it the same as the others?
In an unsorted array the objects are added to memory in sequentially where they don't have to be sorted. The search for a small array is different in that it first sorts the array, which is memory intensive, and then searches the sorted list by using the compare function to see if the object is in the top half or bottom half. This is looped over and over until the item is found. The search method is faster than comparing each item in the list one by one, but it requires a list to be sorted.

3. Are your numbers identical to mine? (Hint: even my numbers are not identical). Why is this? What is being measured in terms of time?
The ids of the Person objects are random so that sorting the lists can be easier or harder depending on the required amount of moving Person objects in that particular iteration. The time generated reflects the difficulty of putting the Person objects into lists. However, the efficiency of each method is reflected by the overall trend in the numbers (e.g. which method adds the objects to the list the fastest). The unsorted arrary generally gets added in the same amount of time because it doesn't need to shuffle memory address around.
 
4. Is the Person object always being added into the same place for all the lists? Does this matter for the timing?
The id of WALDO is random so that its placement can be closer to the beginning or end of the 10000 Person list. The search methods (except for runArraySearch) start from the beginning of the list and go to the end. The method will take less time if WALDO is towards the front of the list and more time if its towards to end. The id of WALDO doesn't matter as much for runArraySearch method because it repeatedly compares the Person that is searched to the midpoint of the list, and then looks in the first half or second half depending on the where Person is.

5. How could you improve the search time for the linked list, based on what you know about how the sorted array is searched? (You don't have to implement this, just discuss what you could do)
We could create some bookmarks or indices of every 1000 Persons (like a dictionary), and then compare the searched person to each of the bookmarks. If the compareTo yeilds a negative number, then we could search starting at the previous bookmark (or backwards from the current bookmark). This would save time as instead of comparing 5000 Persons on average, you compare on average 5+500 Persons.
