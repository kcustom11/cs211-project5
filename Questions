
1. Why is the sorted ArrayList slower to add to than the Linked List?
The items in an ArraysList are ordered in memory. For a sorted ArrayList, everytime an object is added, the memory addresses of the objects following the location of the added item, must be moved forward in memory. This is memory intensive. A Linked List creates a new memory address for the added node, which is given a pointer to the next node and previous node in the list. ArrayLists are efficient in accessing objects because if you know an index, you can access that space in memory. However they are inefficient in adding data because they are 1. fixed in size and 2. adding new indices requires the copying of all the data to a new array with the new object inserted. Linked lists have the opposite characteristics: 1. they are slow in accessing a certain index, because a search function has to travel from the head node to each sucessive node in order to find the one being searched, and 2. they are efficient in adding data because the entire list does not have to be copied.

2. I thought we said that arrays are slow. Why is add so quick for the unsorted array? What kind of search is the sorted array using? Is it the same as the others?
In an unsorted array the objects are added to memory sequentially where they don't have to be rearranged as each object is added to the list. The search method for the small array is different in that it first sorts the array, which is memory intensive, and then searches the sorted list by using the compare function to see if the object is in the top half or bottom half. This is looped over and over until the item is found. The search method is faster than comparing each item in the list one by one, but it requires a list to be sorted.

3. Are your numbers identical to mine? (Hint: even my numbers are not identical). Why is this? What is being measured in terms of time?
The ids of the Person objects are random so that sorting the lists can be easier or harder depending on the required amount of moving Person objects in that particular iteration. The time generated reflects the difficulty of putting the Person objects into lists. However, the efficiency of each method is reflected by the overall trend in the numbers (e.g. which method adds the objects to the list the fastest). The unsorted arrary and unsorted Array List generally gets added in the same amount of time because it doesn't need to shuffle memory address around. The time of the linked list and sorted array list take longer because of the time the adjust the pointers or move objects around in memory.
 
4. Is the Person object always being added into the same place for all the lists? Does this matter for the timing?
The id of WALDO is random so that its placement can be closer to the beginning or end of the 10000 Person list. The search methods (except for runArraySearch) start from the beginning of the list and go to the end. The method will take less time if WALDO is towards the front of the list and more time if its towards to end. The id of WALDO doesn't matter as much for runArraySearch method because it repeatedly compares the Person that is searched to the midpoint of the list, and then looks in the first half or second half depending on the where Person is.

5. How could you improve the search time for the linked list, based on what you know about how the sorted array is searched? (You don't have to implement this, just discuss what you could do)
We could create some bookmarks or indices of every 1000 Persons (like a dictionary), and then compare the searched person to each of the bookmarks. If the compareTo yeilds a negative number, then we could search starting at the previous bookmark (or backwards from the current bookmark). This would save time as instead of comparing 5000 Persons on average, you compare on average 5+500 Persons.
